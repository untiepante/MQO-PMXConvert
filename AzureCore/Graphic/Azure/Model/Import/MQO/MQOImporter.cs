using System;
using System.Collections.Generic;
using System.Windows.Forms;
using System.ComponentModel;
using System.Threading.Tasks;
using AzureCore.Graphic.Azure.Model.Import.PMX;
using System.Text;

namespace AzureCore.Graphic.Azure.Model.Import.MQO
{
    public class MQOImporter
    {
        public String Caption { get { return "Metasequoia"; } }
        public String Ext { get { return ".mqo"; } }

        private string mqopath = null;
        public void ConvertMqo(string mqopath, string outpathWithoutExt)
        {
            this.mqopath = mqopath;

            Console.WriteLine("MQOファイルを読込中...");
            using (MQOFile mqo = MQOFile.load(mqopath, true)) // 三角面化して読み込む
            {
                if (mqo == null) throw new Exception("読み込み失敗。おそらくmqoファイルの構文エラー。");

                if (mqo.ObjectByList.Count == 0) throw new Exception("オブジェクトが空です。");

                //PMXを作成
                PMXModel pmx = new PMXModel();
                pmx.Info = new PMXInfo();
                pmx.Info.ModelName = mqo.ObjectByList[0].Name;
                pmx.Info.ModelEnglishName = "";
                pmx.Info.Comments = "Generated by azure lib.";
                pmx.Info.EnglishComments = "Generated by azure lib.";
                pmx.Header.AddInfo = new byte[8];
                pmx.Header.AddInfoLength = 8;

                //材質を作成
                if (mqo.Material.Count == 0) throw new Exception("材質がありません。少なくとも1つ材質が必要です。");
                pmx.TextureList = new List<string>();
                pmx.Materials = new PMXMaterial[mqo.Material.Count];
                for (int i = 0; i < mqo.Material.Count; i++)
                {
                    MQOMaterial m = mqo.Material[i];
                    PMXMaterial pm = new PMXMaterial();

                    pm.MaterialName = m.Name;
                    pm.MaterialEnglishName = "";
                    pm.Diffuse = new float[4]
                    {
                        (float)(m.Color.R * m.Diffuse),
                        (float)(m.Color.G * m.Diffuse),
                        (float)(m.Color.B * m.Diffuse),
                        (float)m.Color.A
                    };
                    pm.Specular = new float[3]
                    {
                        (float)(m.Color.R * m.Specular),
                        (float)(m.Color.G * m.Specular),
                        (float)(m.Color.B * m.Specular)
                    };
                    pm.SpecularPower = (float)m.Power;
                    pm.Ambient = new float[3]
                    {
                        (float)(m.Color.R * m.Ambient),
                        (float)(m.Color.G * m.Ambient),
                        (float)(m.Color.B * m.Ambient)
                    };

                    if (!pmx.TextureList.Contains(m.Tex))
                        pmx.TextureList.Add(m.Tex);
                    pm.DiffuseTextureIndex = pmx.TextureList.IndexOf(m.Tex);
                    pm.AttributeFlags = 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3 | 1 << 4;
                    pm.EdgeColor = new float[4]
                    {
                        0.0f, 0.0f, 0.0f, 1.0f
                    };
                    pm.EdgeWidth = 1.0f;
                    pm.SphereMapIndex = -1;
                    pm.UseInternalToon = true;
                    pm.ToonTextureIndex = 0;
                    pm.Memo = "";
                    pm.VertexCount = 0; //オブジェクト処理時に計算する

                    pmx.Materials[i] = pm;
                }

                //各オブジェクトを処理
                //ただし、非表示オブジェクトはスキップ
                //法線を計算する
                for (int i = 0; i < mqo.ObjectByList.Count; i++)
                {
                    MQOObject obj = mqo.ObjectByList[i];
                    if (obj.Visible) obj.CalcNormals();
                }

                //頂点を登録する
                TempVertexGroup vertexGroup = new TempVertexGroup();
                TempPolygonGroup[] polygonGroups = new TempPolygonGroup[mqo.Material.Count];
                for (int i = 0; i < polygonGroups.Length; i++)
                    polygonGroups[i] = new TempPolygonGroup(i);
                for (int objID = 0; objID < mqo.ObjectByList.Count; objID++)
                {
                    Console.WriteLine("MQOオブジェクトを登録中...(" + objID.ToString() + "/" + mqo.ObjectByList.Count.ToString() + ")");
                    MQOObject obj = mqo.ObjectByList[objID];
                    if (!obj.Visible)
                        continue; //非表示

                    for (int faceID = 0; faceID < obj.Face.Count; faceID++)
                    {
                        MQOFace face = obj.Face[faceID];
                        PrintProgress(faceID, obj.Face.Count);

                        int materialID = face.MatID < 0 ? 0 : face.MatID; //材質割り当てのない面は材質0として処理

                        int[] registIDs = new int[3];
                        //if (obj.VertexIDsface.VertexID[0]])
                        for (int i = 0; i < 3; i++)
                        {
                            TempVertexGroup.VertexSourceID vertex;
                            vertex = new TempVertexGroup.VertexSourceID()
                            {
                                VertexID = obj.VertexIDs[face.VertexID[i]],
                                ObjectID = obj.UID,
                                NormalID = face.NormalID[i],
                                UvID = face.UVID[i],
                                VertexIndex = face.VertexID[i],
                                ObjectIndex = objID
                            };

                            registIDs[i] = vertexGroup.Add(vertex);
                        }
                        polygonGroups[materialID].Add(registIDs[0], registIDs[1], registIDs[2]);
                    }

                    Console.WriteLine();
                }

                //ボーンを読み込む
                MqxReader mqxReader = new MqxReader();
                if (!mqxReader.Load(mqopath))
                {
                    Console.WriteLine("ボーン情報は読み込まれませんでした...");
                    mqxReader.bones = new MqoBone[0];
                }
                else
                {
                    Console.WriteLine("ボーン情報が読み込まれました!");
                }
                pmx.Bones = new PMXBone[mqxReader.bones.Length];
                for (int i = 0; i < pmx.Bones.Length; i++)
                {
                    MqoBone bn = mqxReader.bones[i];
                    PMXBone pbn = new PMXBone();

                    pbn.BoneName = bn.name;
                    pbn.BoneEnglishName = "";
                    pbn.Position = bn.world_position.ToArray();
                    pbn.Position[2] *= -1f;
                    pbn.ParentBoneIndex = bn.parent == null ? -1 : GetBoneIndex(mqxReader.bones, bn.parent);
                    pbn.ViewBoneIndex = Array.FindIndex(mqxReader.bones, (b) => b.parent == bn);
                    if (pbn.ViewBoneIndex >= 0)
                        pbn.ViewBoneIndex = GetBoneIndex(mqxReader.bones, mqxReader.bones[pbn.ViewBoneIndex]);
                    pbn.TransformLevel = 0;
                    pbn.AttributeFlag =
                        1 << 0 | 1 << 1 | 1 << 2 | 1 << 3 | 1 << 4 | 0 << 5 | 0 << 8 | 0 << 9 | 0 << 10 | 0 << 11 | 0 << 12 | 0 << 13;

                    pmx.Bones[i] = pbn;
                }

                BoneIndexTable boneIndexTable = new BoneIndexTable(pmx.Bones.Length);
                while (true)
                {
                    bool doned = false;
                    for (int i1 = 0; i1 < pmx.Bones.Length; i1++)
                    {
                        PMXBone bone1 = pmx.Bones[i1];
                        int targetedMin = -1; //bone1を親だと思っているボーン

                        int mqxId = boneIndexTable.ConvertToMQX(i1);
                        for (int i2 = 0; i2 < i1; i2++) //bone1以前にあるものを検索
                        {
                            PMXBone bone2 = pmx.Bones[i2];
                            if (bone2.ParentBoneIndex == mqxId)
                            {
                                targetedMin = i2;
                                break;
                            }
                        }

                        //手前に何もない時
                        if (targetedMin < 0)
                            continue;

                        //手前に子ボーンがあるとき、親を子の一個手前に移動
                        for (int i2 = i1; i2 >= targetedMin + 1; i2--)
                        {
                            PMXBone bswp = pmx.Bones[i2 - 1];
                            pmx.Bones[i2 - 1] = pmx.Bones[i2];
                            pmx.Bones[i2] = bswp;
                        }
                        boneIndexTable.MoveRegionToTail(targetedMin, i1 - 1);

                        doned = true;
                    }

                    if (!doned)
                        break;
                }
                for (int i = 0; i < pmx.Bones.Length; i++)
                {
                    if (pmx.Bones[i].ParentBoneIndex != -1)
                        pmx.Bones[i].ParentBoneIndex = boneIndexTable.ConvertToPMX(pmx.Bones[i].ParentBoneIndex);
                    if (pmx.Bones[i].ViewBoneIndex != -1)
                        pmx.Bones[i].ViewBoneIndex = boneIndexTable.ConvertToPMX(pmx.Bones[i].ViewBoneIndex);
                }

                //頂点を設定する
                Console.WriteLine("頂点を設定中...");
                pmx.Vertexes = new PMXVertex[vertexGroup.Vertices.Count];
                bool over2 = false;
                List<MqoWeit> weightList = new List<MqoWeit>();
                foreach (var b in mqxReader.bones)
                {
                    weightList.AddRange(b.weits.ToArray());
                }

                for (int i = 0; i < pmx.Vertexes.Length; i++)
                {
                    PMXVertex pv = new PMXVertex();
                    TempVertexGroup.TempVertex v = vertexGroup.Vertices[i];

                    PrintProgress(i, pmx.Vertexes.Length);

                    pv.Position = new float[3]
                    { 
                        (float)mqo.ObjectByList[v.SourceID.ObjectIndex].Vertex[v.SourceID.VertexIndex].X,
                        (float)mqo.ObjectByList[v.SourceID.ObjectIndex].Vertex[v.SourceID.VertexIndex].Y,
                        -(float)mqo.ObjectByList[v.SourceID.ObjectIndex].Vertex[v.SourceID.VertexIndex].Z
                    };
                    pv.Normal = new float[3]
                    {
                        (float)mqo.ObjectByList[v.SourceID.ObjectIndex].Normal[v.SourceID.NormalID].X,
                        (float)mqo.ObjectByList[v.SourceID.ObjectIndex].Normal[v.SourceID.NormalID].Y,
                        (float)mqo.ObjectByList[v.SourceID.ObjectIndex].Normal[v.SourceID.NormalID].Z
                    };
                    pv.TextureCoord = new float[2]
                    {
                        (float)mqo.ObjectByList[v.SourceID.ObjectIndex].UV[v.SourceID.UvID].U,
                        (float)mqo.ObjectByList[v.SourceID.ObjectIndex].UV[v.SourceID.UvID].V
                    };

                    pv.EdgeRaito = 1.0f;
                    pv.AddTextureCoord = new float[0][];
                    List<MqoWeit> weights = weightList.FindAll(w => w.object_id == v.SourceID.ObjectID && w.vertex_id == v.SourceID.VertexID);
                    switch (weights.Count)
                    {
                        case 0:
                            pv.SkinningMethod = PMXVertex.enumSkinningMethod.BDEF1;
                            pv.BoneIndices = new int[1] { 0 };
                            pv.BoneWeights = new float[1] { 0f };
                            break;
                        case 1:
                            pv.SkinningMethod = PMXVertex.enumSkinningMethod.BDEF1;
                            pv.BoneIndices = new int[1] { 
                                boneIndexTable.ConvertToPMX( GetBoneIndex(mqxReader.bones, weights[0].node_id)) };
                            pv.BoneWeights = new float[1] { 1f };
                            break;
                        case 2:
                            pv.SkinningMethod = PMXVertex.enumSkinningMethod.BDEF2;
                            pv.BoneIndices = new int[2] {
                                boneIndexTable.ConvertToPMX(GetBoneIndex(mqxReader.bones, weights[0].node_id)),
                                boneIndexTable.ConvertToPMX(GetBoneIndex(mqxReader.bones, weights[1].node_id)) };
                            pv.BoneWeights = new float[2] { weights[0].weit, weights[1].weit };
                            break;
                        case 3:
                            over2 = true;
                            pv.SkinningMethod = PMXVertex.enumSkinningMethod.BDEF4;
                            pv.BoneIndices = new int[4] { 
                                boneIndexTable.ConvertToPMX(GetBoneIndex(mqxReader.bones, weights[0].node_id)), 
                                boneIndexTable.ConvertToPMX(GetBoneIndex(mqxReader.bones, weights[1].node_id)), 
                                boneIndexTable.ConvertToPMX(GetBoneIndex(mqxReader.bones, weights[2].node_id)), 0 };
                            pv.BoneWeights = new float[4] { weights[0].weit, weights[1].weit, weights[2].weit, 0f };
                            break;
                        case 4:
                            over2 = true;

                            pv.SkinningMethod = PMXVertex.enumSkinningMethod.BDEF4;
                            pv.BoneIndices = new int[4] { 
                                boneIndexTable.ConvertToPMX(GetBoneIndex(mqxReader.bones, weights[0].node_id)),
                                boneIndexTable.ConvertToPMX(GetBoneIndex(mqxReader.bones, weights[1].node_id)),
                                boneIndexTable.ConvertToPMX(GetBoneIndex(mqxReader.bones, weights[2].node_id)), 
                                boneIndexTable.ConvertToPMX(GetBoneIndex(mqxReader.bones, weights[3].node_id)) };
                            pv.BoneWeights = new float[4] { weights[0].weit, weights[1].weit, weights[2].weit, weights[3].weit };
                            break;
                        default:
                            while (weights.Count > 4)
                            {
                                MqoWeit minWei = weights[0];
                                for (int wi = 1; wi < weights.Count; wi++)
                                    if (minWei.weit > weights[wi].weit)
                                        minWei = weights[wi];

                                weights.Remove(minWei);
                                pv.SkinningMethod = PMXVertex.enumSkinningMethod.BDEF4;
                                pv.BoneIndices = new int[4] { 
                                    boneIndexTable.ConvertToPMX(GetBoneIndex(mqxReader.bones, weights[0].node_id)), 
                                    boneIndexTable.ConvertToPMX(GetBoneIndex(mqxReader.bones, weights[1].node_id)),
                                    boneIndexTable.ConvertToPMX(GetBoneIndex(mqxReader.bones, weights[2].node_id)), 
                                    boneIndexTable.ConvertToPMX(GetBoneIndex(mqxReader.bones, weights[3].node_id)) };
                                pv.BoneWeights = new float[4] { weights[0].weit, weights[1].weit, weights[2].weit, weights[3].weit };
                            }
                            break;
                    }

                    pmx.Vertexes[i] = pv;
                }
                if (over2)
                    System.Windows.Forms.MessageBox.Show("ボーンの参照数が2よりも大きい頂点が有りました");

                //ポリゴンを登録
                List<TempPolygonGroup.TempPolygon> polygonList = new List<TempPolygonGroup.TempPolygon>();
                int faceCount = 0;
                for (int i = 0; i < polygonGroups.Length; i++)
                {
                    pmx.Materials[i].VertexCount = polygonGroups[i].Polygons.Count * 3;
                    polygonList.AddRange(polygonGroups[i].Polygons);
                    faceCount += pmx.Materials[i].VertexCount;
                }
                List<PMXMaterial> materials = new List<PMXMaterial>(pmx.Materials);
                for (int i = 0; i < materials.Count; i++)
                {
                    if (materials[i].VertexCount == 0)
                    {
                        materials.Remove(materials[i]);
                        i--;
                    }
                }
                pmx.Materials = materials.ToArray();
                pmx.FaceVertexes = new int[faceCount];
                for (int i = 0; i < faceCount / 3; i++)
                {
                    pmx.FaceVertexes[i * 3 + 0] = polygonList[i].VertexID1;
                    pmx.FaceVertexes[i * 3 + 1] = polygonList[i].VertexID2;
                    pmx.FaceVertexes[i * 3 + 2] = polygonList[i].VertexID3;
                }

                //記録
                pmx.Header = new PMXHeader();
                pmx.Header.AddInfo = new byte[8] { 0, 0, 4, 4, 4, 4, 4, 4 };
                pmx.Header.AddInfoLength = 8;
                pmx.Header.HeadCode = new byte[4] { 80, 77, 88, 32 };
                pmx.Header.Version = 2.0f;

                //表示枠を設定
                pmx.Displays = new PMXDisplay[pmx.Bones.Length];
                for (int i = 0; i < pmx.Bones.Length; i++)
                {
                    PMXDisplay e = new PMXDisplay();
                    PMXBone b = pmx.Bones[i];

                    e.Name = b.BoneName;
                    e.EnglishName = b.BoneEnglishName;
                    e.AttributeFlags = 0; //一般
                    e.Elements = new PMXDisplay.PMXDisplayElement[1];
                    e.Elements[0] = new PMXDisplay.PMXDisplayElement();
                    e.Elements[0].KindFlags = 0;
                    e.Elements[0].IndexData = i;

                    pmx.Displays[i] = e;
                }

                string outPath = outpathWithoutExt + ".pmx";
                if (System.IO.File.Exists(outPath))
                    System.IO.File.Delete(outPath);
                using (System.IO.Stream ws = System.IO.File.OpenWrite(outPath))
                    pmx.Write(ws, 1.0f, 1.0f);
            }

        }

        private int GetBoneIndex(MqoBone[] array, MqoBone bone)
        {
            for (int i = 0; i < array.Length; i++)
            {
                if (array[i] == bone)
                    return i;
            }

            return -1;
        }
        private int GetBoneIndex(MqoBone[] array, int boneID)
        {
            for (int i = 0; i < array.Length; i++)
            {
                if (array[i].node_id == boneID)
                    return i;
            }

            return -1;
        }
        private static void PrintProgress(int cur, int max)
        {
            int div = max / 10;
            if (div == 0 || cur % div > 0 || cur / div > 10)
                return;

            Console.Write((cur * 10 / div).ToString() + "%...");
        }
    }


    class BoneIndexTable
    {
        int[] MQX2PMXs;


        public BoneIndexTable(int length)
        {
            MQX2PMXs = new int[length];
            for (int i = 0; i < length; i++)
                MQX2PMXs[i] = i;
        }

        public void MoveRegionToTail(int pmxIdxStart, int pmxIdxEnd)
        {
            int[] movedMqxIndices = new int[pmxIdxEnd - pmxIdxStart + 1];
            for (int i = pmxIdxStart; i <= pmxIdxEnd; i++)
            {
                int mqxIdx = ConvertToMQX(i);
                movedMqxIndices[i - pmxIdxStart] = mqxIdx;
            }
            int lappedMqxIndex = ConvertToMQX(pmxIdxEnd + 1);
            
            //重複してしまう最後の要素を前に持ってくる
            MQX2PMXs[lappedMqxIndex] = pmxIdxStart;

            //ブロック分を1インクリメント
            for (int i = 0; i < movedMqxIndices.Length; i++)
            {
                MQX2PMXs[movedMqxIndices[i]]++;
            }
        }

        public void SwapIndex(int pmxIdx1, int pmxIdx2)
        {
            int mqxIdx1 = ConvertToMQX(pmxIdx1);
            int mqxIdx2 = ConvertToMQX(pmxIdx2);

            int swp = MQX2PMXs[mqxIdx1];
            MQX2PMXs[mqxIdx1] = MQX2PMXs[mqxIdx2];
            MQX2PMXs[mqxIdx2] = swp;
        }

        public int ConvertToMQX(int index)
        {
            return Array.IndexOf(MQX2PMXs, index);
        }

        public int ConvertToPMX(int index)
        {
            return MQX2PMXs[index];
        }
    }

    public class TempVertexGroup
    {
        public class VertexSourceID : IEquatable<VertexSourceID>
        {
            public int ObjectID, VertexID, UvID, NormalID, VertexIndex, ObjectIndex;


            public override int GetHashCode()
            {
                return VertexID.GetHashCode() ^ ObjectID.GetHashCode() ^ UvID.GetHashCode() ^ NormalID.GetHashCode() ^ VertexIndex.GetHashCode() ^ ObjectIndex.GetHashCode();
            }

            public bool Equals(VertexSourceID other)
            {
                return ObjectID == other.ObjectID &&
                        VertexID == other.VertexID &&
                        UvID == other.UvID &&
                        NormalID == other.NormalID &&
                        VertexIndex == other.VertexIndex &&
                        ObjectIndex == other.ObjectIndex;
            }
        }
        public class TempVertex
        {
            public VertexSourceID SourceID;


            public TempVertex(VertexSourceID sid)
	        {
                SourceID = sid;
	        }
        }
        public List<TempVertex> Vertices;
        public Dictionary<VertexSourceID, int> SearchTable;


        public TempVertexGroup()
        {
            Vertices = new List<TempVertex>();
            SearchTable = new Dictionary<VertexSourceID, int>();
        }

        public int Add(VertexSourceID sid)
        {
            int idx;
            if ((idx = IndexOf(sid)) < 0)
            {
                Vertices.Add(new TempVertex(sid));
                idx = Vertices.Count - 1;
                SearchTable.Add(sid, idx);
            }

            return idx;
        }

        private int IndexOf(VertexSourceID sid)
        {
            if (SearchTable.ContainsKey(sid))
                return SearchTable[sid];
            else
                return -1;
        }
    }
    public class TempPolygonGroup
    {
        public class TempPolygon
        {
            //TempVertexGroupでのID
            public int VertexID1, VertexID2, VertexID3;
        }
        public List<TempPolygon> Polygons;
        public int MaterialID;


        public TempPolygonGroup(int materialID)
        {
            this.MaterialID = materialID;
            Polygons = new List<TempPolygon>();
        }

        public void Add(int vid1, int vid2, int vid3)
        {
            TempPolygon p = new TempPolygon()
            {
                VertexID1 = vid1, VertexID2 = vid2, VertexID3 = vid3
            };
            Polygons.Add(p);
        }
    }
    public class MQXBoneReader
    {
        public class MQOBone
        {
            public int ID;
            public string Name;
            public float[] Rotation;
            public float[] Translation;

        }
    }
}
